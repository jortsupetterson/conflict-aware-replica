import { type AclAssignment, type DacumentEventMap, type DocFieldAccess, type DocSnapshot, type DocValue, type RoleKeys, type RolePublicKeys, type SchemaDefinition, type SchemaId, type SignedOp, type Role, array, map, record, register, set, text } from "./types.js";
export declare class Dacument<S extends SchemaDefinition> {
    static schema: <Schema extends SchemaDefinition>(schema: Schema) => Schema;
    static register: typeof register;
    static text: typeof text;
    static array: typeof array;
    static set: typeof set;
    static map: typeof map;
    static record: typeof record;
    static generateId(): string;
    static computeSchemaId(schema: SchemaDefinition): Promise<SchemaId>;
    static create<Schema extends SchemaDefinition>(params: {
        schema: Schema;
        ownerId: string;
        docId?: string;
    }): Promise<{
        docId: string;
        schemaId: SchemaId;
        roleKeys: RoleKeys;
        snapshot: DocSnapshot;
    }>;
    static load<Schema extends SchemaDefinition>(params: {
        schema: Schema;
        actorId: string;
        roleKey?: JsonWebKey;
        snapshot: DocSnapshot;
    }): Promise<DacumentDoc<Schema>>;
    readonly docId: string;
    readonly actorId: string;
    readonly schema: S;
    readonly schemaId: SchemaId;
    private readonly fields;
    private readonly aclLog;
    private readonly clock;
    private readonly roleKey?;
    private readonly roleKeys;
    private readonly opLog;
    private readonly opTokens;
    private currentRole;
    private readonly revokedCrdtByField;
    private readonly eventListeners;
    private readonly pending;
    private readonly ackByActor;
    readonly acl: {
        setRole: (actorId: string, role: Role) => void;
        getRole: (actorId: string) => Role;
        knownActors: () => string[];
        snapshot: () => AclAssignment[];
    };
    constructor(params: {
        schema: S;
        schemaId: SchemaId;
        docId: string;
        actorId: string;
        roleKey?: JsonWebKey;
        roleKeys: RolePublicKeys;
    });
    addEventListener<K extends keyof DacumentEventMap>(type: K, listener: (event: DacumentEventMap[K]) => void): void;
    removeEventListener<K extends keyof DacumentEventMap>(type: K, listener: (event: DacumentEventMap[K]) => void): void;
    onChange(listener: (ops: SignedOp[]) => void): () => void;
    onFieldChange<K extends keyof S & string>(field: K, listener: (value: DocValue<S>[K]) => void): () => void;
    onAnyFieldChange(listener: (field: keyof S & string, value: DocValue<S>[keyof S & string]) => void): () => void;
    onError(listener: (error: Error) => void): () => void;
    onRevoked(listener: (event: DacumentEventMap["revoked"]) => void): () => void;
    flush(): Promise<void>;
    snapshot(): DocSnapshot;
    merge(input: SignedOp | SignedOp[] | string | string[]): Promise<{
        accepted: SignedOp[];
        rejected: number;
    }>;
    ack(): void;
    private setRegisterValue;
    private createFieldView;
    private shadowFor;
    private isRevoked;
    private readCrdt;
    private revokedCrdt;
    private createTextView;
    private createArrayView;
    private createSetView;
    private createMapView;
    private createRecordView;
    private commitArrayMutation;
    private commitSetMutation;
    private commitMapMutation;
    private commitRecordMutation;
    private capturePatches;
    private queueLocalOp;
    private applyRemotePayload;
    private applyAclPayload;
    private applyRegisterPayload;
    private applyNodePayload;
    private applySetNodes;
    private applyMapNodes;
    private applyRecordNodes;
    private validateDagNodeValues;
    private emitListOps;
    private diffSet;
    private diffMap;
    private diffRecord;
    private setRole;
    private recordValue;
    private mapValue;
    private fieldValue;
    private emitEvent;
    private emitMerge;
    private emitRevoked;
    private emitError;
    private canWriteField;
    private canWriteAcl;
    private assertWritable;
    private assertValueType;
    private assertValueArray;
    private assertMapKey;
    private isValidPayload;
    private resolveSignerRole;
    private assertSchemaKeys;
}
export type DacumentDoc<S extends SchemaDefinition> = Dacument<S> & DocFieldAccess<S>;
